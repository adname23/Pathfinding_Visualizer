[{"/Users/adithya/Documents/Pathfinding_Visualizer/src/reportWebVitals.js":"1","/Users/adithya/Documents/Pathfinding_Visualizer/src/PathFindingVisualizer/Node/Node.jsx":"2","/Users/adithya/Documents/Pathfinding_Visualizer/src/App.js":"3","/Users/adithya/Documents/Pathfinding_Visualizer/src/Algorithms/dijkstra.js":"4","/Users/adithya/Documents/Pathfinding_Visualizer/src/index.js":"5","/Users/adithya/Documents/Pathfinding_Visualizer/src/PathFindingVisualizer/PathfindingVisualizer.jsx":"6"},{"size":362,"mtime":1608094642000,"results":"7","hashOfConfig":"8"},{"size":682,"mtime":1608181405000,"results":"9","hashOfConfig":"8"},{"size":279,"mtime":1608097091000,"results":"10","hashOfConfig":"8"},{"size":2331,"mtime":1608181409000,"results":"11","hashOfConfig":"8"},{"size":500,"mtime":1608094642000,"results":"12","hashOfConfig":"8"},{"size":4434,"mtime":1608355635000,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"1p0pu6r",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"26"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"29"},"/Users/adithya/Documents/Pathfinding_Visualizer/src/reportWebVitals.js",[],["30","31"],"/Users/adithya/Documents/Pathfinding_Visualizer/src/PathFindingVisualizer/Node/Node.jsx",[],"/Users/adithya/Documents/Pathfinding_Visualizer/src/App.js",[],["32","33"],"/Users/adithya/Documents/Pathfinding_Visualizer/src/Algorithms/dijkstra.js",[],"/Users/adithya/Documents/Pathfinding_Visualizer/src/index.js",[],["34","35"],"/Users/adithya/Documents/Pathfinding_Visualizer/src/PathFindingVisualizer/PathfindingVisualizer.jsx",["36"],"import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport styled from 'styled-components'\nimport {dijkstra, getNodesInShortestPathOrder} from '../Algorithms/dijkstra';\n\nimport './PathfindingVisualizer.css';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({grid});\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true});\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  handleMouseUp() {\n    this.setState({mouseIsPressed: false});\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 50 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    const {grid} = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n\n    return (\n      <>\n        <Button onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm\n        </Button>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 23; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 56; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst Button = styled.button`\n  background-color: black;\n  color: white;\n  font-size: 20px;\n  align-items: top;\n  padding: 10px 60px;\n  border-radius: 5px;\n  margin: 10px 0px;\n  cursor: pointer;\n`;",{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"37","replacedBy":"41"},{"ruleId":"39","replacedBy":"42"},{"ruleId":"37","replacedBy":"43"},{"ruleId":"39","replacedBy":"44"},{"ruleId":"45","severity":1,"message":"46","line":149,"column":7,"nodeType":"47","messageId":"48","endLine":149,"endColumn":13},"no-native-reassign",["49"],"no-negated-in-lhs",["50"],["49"],["50"],["49"],["50"],"no-unused-vars","'Button' is assigned a value but never used.","Identifier","unusedVar","no-global-assign","no-unsafe-negation"]